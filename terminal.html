<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hugo/Terminal</title>
    <link rel="icon" type="image/jpeg" href="logo.jpg">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Y501HY0RS"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-4Y501HY0RS');
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #0b0f19;
            color: #10b981;
            /* Emerald 500 */
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 18px;
            background-color: #10b981;
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        /* Matrix Effect Canvas */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            opacity: 0.1;
            pointer-events: none;
            display: none;
        }

        .terminal-content {
            position: relative;
            z-index: 10;
        }
    </style>
</head>

<body
    class="h-screen w-full overflow-hidden p-4 md:p-8 text-sm md:text-base selection:bg-green-900 selection:text-white">

    <canvas id="matrix-canvas"></canvas>

    <div class="max-w-4xl mx-auto h-full flex flex-col terminal-content">
        <!-- Output Area -->
        <div id="output" class="flex-grow overflow-y-auto space-y-1 pb-4 scrollbar-hide">
            <div class="mb-4">
                <p>Welcome to Hugo OS v1.0.0 (tty1)</p>
                <p>System initialized at <span id="boot-time"></span></p>
                <p>Type <span class="text-white font-bold">'help'</span> to see available commands.</p>
            </div>
        </div>

        <!-- Input Area -->
        <div class="flex items-center gap-2 pt-2 border-t border-slate-800">
            <span id="prompt" class="text-purple-400 whitespace-nowrap">visitor@hugo-portfolio:~$</span>
            <input type="text" id="cmd-input"
                class="bg-transparent border-none outline-none flex-grow text-white font-mono placeholder-slate-700"
                autocomplete="off" autofocus spellcheck="false">
        </div>
    </div>

    <script>
        // --- Virtual File System ---
        const fileSystem = {
            '/home/visitor': {
                type: 'dir',
                children: {
                    'about_me.txt': { type: 'file', content: "My name is Hugo Sevilla MartÃ­nez. I am a Robotics Engineer passionate about Computer Vision, ROS, and Startups." },
                    'contact_info.txt': { type: 'file', content: "Email: hugosema.19@gmail.com\nPhone: +34 647 73 12 52\nLinkedIn: linkedin.com/in/hugo-sevilla\nGitHub: github.com/Eugegeuge" },
                    'technical_skills.log': { type: 'file', content: "[INFO] Loaded Modules:\n- Python (Expert)\n- ROS 2 (Advanced)\n- C++ (Intermediate)\n- Computer Vision (OpenCV, TensorFlow)\n- Unity 3D & VR" },
                    'cv_full.pdf': { type: 'file', action: 'download', url: 'CV-en.pdf' },
                    'projects': {
                        type: 'dir',
                        children: {
                            'kinova_vr.sh': { type: 'file', action: 'navigate', url: 'kinova.html' },
                            'mathsolver_ai.py': { type: 'file', action: 'navigate', url: 'mathsolver.html' },
                            'drone_autonomous.md': { type: 'file', content: "# Autonomous Drone Tracking\n\nProposed TFG project focusing on Edge AI object tracking on a quadcopter." }
                        }
                    }
                }
            }
        };

        // --- State ---
        let currentPath = ['home', 'visitor'];
        let commandHistory = [];
        let historyIndex = -1;

        // --- DOM Elements ---
        const outputDiv = document.getElementById('output');
        const inputField = document.getElementById('cmd-input');
        const promptSpan = document.getElementById('prompt');
        const bootTimeSpan = document.getElementById('boot-time');

        // Initialize
        bootTimeSpan.innerText = new Date().toLocaleString();
        inputField.focus();

        // Keep focus
        document.addEventListener('click', () => inputField.focus());

        // --- Core Functions ---

        // Helper to retrieve node from path array
        function getNode(pathArray) {
            // Root validation: restricted to /home/visitor for this demo
            if (pathArray.length < 2 || pathArray[0] !== 'home' || pathArray[1] !== 'visitor') return null;

            let node = fileSystem['/home/visitor'];
            // Iterate from index 2 (after home/visitor)
            for (let i = 2; i < pathArray.length; i++) {
                if (node.type !== 'dir' || !node.children) return null; // Can't traverse non-dir
                const name = pathArray[i];
                if (!node.children[name]) return null; // Child not found
                node = node.children[name];
            }
            return node;
        }

        // Robust Path Resolver
        function resolvePath(pathStr) {
            // Normalize slashes
            pathStr = pathStr.trim();
            if (!pathStr) return { path: [...currentPath], node: getNode(currentPath) };

            const parts = pathStr.split('/').filter(p => p.length > 0);
            let resolvedPath = [...currentPath];

            // Handle root or home alias
            if (pathStr.startsWith('/')) {
                // Treat / as /home/visitor (virtual root)
                resolvedPath = ['home', 'visitor'];
            } else if (parts.length > 0 && parts[0] === '~') {
                resolvedPath = ['home', 'visitor'];
                parts.shift();
            }

            // Iterate parts
            for (let part of parts) {
                if (part === '.') continue; // Check ./ implicitly done here
                if (part === '..') {
                    if (resolvedPath.length > 2) resolvedPath.pop();
                } else {
                    resolvedPath.push(part);
                }
            }

            const node = getNode(resolvedPath);
            return { path: resolvedPath, node: node };
        }

        function print(text, type = 'normal') {
            const line = document.createElement('div');
            if (type === 'error') line.className = 'text-red-400';
            else if (type === 'success') line.className = 'text-green-400';
            else if (type === 'info') line.className = 'text-blue-400';
            else line.className = 'text-slate-300 whitespace-pre-wrap';

            line.textContent = text;
            outputDiv.appendChild(line);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        function printHTML(html) {
            const line = document.createElement('div');
            line.innerHTML = html;
            outputDiv.appendChild(line);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        function execute(cmdRaw) {
            const cmdParts = cmdRaw.trim().split(/\s+/);
            const cmd = cmdParts[0].toLowerCase();
            const args = cmdParts.slice(1);

            // Print Command Echo
            const promptText = promptSpan.innerText;
            const echo = document.createElement('div');
            echo.innerHTML = `<span class="text-purple-400">${promptText}</span> <span class="text-white">${cmdRaw}</span>`;
            outputDiv.appendChild(echo);

            if (!cmd) return;

            commandHistory.push(cmdRaw);
            historyIndex = commandHistory.length;

            switch (cmd) {
                case 'help':
                    printHTML(`
                        <div class="space-y-1 mb-2">
                            <div class="text-purple-400 mb-2">Available commands:</div>
                            <div class="grid grid-cols-[120px_1fr] gap-2">
                                <span class="text-green-400">ls, ll, dir</span> <span class="text-slate-400">List directory contents</span>
                                <span class="text-green-400">cd [dir]</span> <span class="text-slate-400">Change directory</span>
                                <span class="text-green-400">cat [file]</span> <span class="text-slate-400">Show file content</span>
                                <span class="text-green-400">./[file]</span> <span class="text-slate-400">Execute/Open file</span>
                                <span class="text-green-400">clear</span> <span class="text-slate-400">Clear terminal screen</span>
                                <span class="text-green-400">whoami</span> <span class="text-slate-400">Display current user</span>
                                <span class="text-green-400">matrix</span> <span class="text-slate-400">Toggle Matrix effect</span>
                                <span class="text-green-400">exit</span> <span class="text-slate-400">Return to main portfolio</span>
                            </div>
                        </div>
                    `);
                    break;

                case 'clear':
                    outputDiv.innerHTML = '';
                    break;

                case 'ls':
                case 'll':
                case 'dir':
                    let targetPath = args.length > 0 ? args[0] : ".";
                    let resLs = resolvePath(targetPath);
                    if (resLs.node) {
                        if (resLs.node.type === 'dir') {
                            const files = Object.keys(resLs.node.children).map(name => {
                                const isDir = resLs.node.children[name].type === 'dir';
                                return isDir ? `<span class="text-blue-400 font-bold">${name}/</span>` : `<span class="text-green-300">${name}</span>`;
                            });
                            printHTML(files.join('  '));
                        } else {
                            // Listing a file usually just shows the file name, maybe with permissions in real ls -l
                            // Here just print the name
                            printHTML(`<span class="text-green-300">${resLs.path[resLs.path.length - 1]}</span>`);
                        }
                    } else {
                        print(`ls: cannot access '${targetPath}': No such file or directory`, 'error');
                    }
                    break;

                case 'cd':
                    let cdPath = args.length > 0 ? args[0] : "~";
                    let resCd = resolvePath(cdPath);
                    if (resCd.node && resCd.node.type === 'dir') {
                        currentPath = resCd.path;
                    } else {
                        if (!resCd.node) print(`cd: ${cdPath}: No such file or directory`, 'error');
                        else print(`cd: ${cdPath}: Not a directory`, 'error');
                    }
                    updatePrompt();
                    break;

                case 'cat':
                    if (args.length === 0) {
                        print("usage: cat [file]", 'info');
                        return;
                    }
                    let resCat = resolvePath(args[0]);
                    if (resCat.node && resCat.node.type === 'file') {
                        if (resCat.node.content) print(resCat.node.content);
                        else print("[Binary File] Cannot display content", 'error');
                    } else {
                        if (!resCat.node) print(`cat: ${args[0]}: No such file`, 'error');
                        else print(`cat: ${args[0]}: Is a directory`, 'error');
                    }
                    break;

                case 'sudo':
                    print("Permission denied: You are not Hugo.", 'error');
                    break;

                case 'whoami':
                    print("visitor@portfolio (v1.0)", 'success');
                    break;

                case 'exit':
                    window.location.href = 'index.html';
                    break;

                case 'reboot':
                    location.reload();
                    break;

                case 'matrix':
                    const canvas = document.getElementById('matrix-canvas');
                    if (canvas.style.display === 'block') {
                        canvas.style.display = 'none';
                        print("Matrix mode deactivated.");
                    } else {
                        canvas.style.display = 'block';
                        startMatrix();
                        print("Wake up, Neo...", 'success');
                    }
                    break;

                default:
                    // Handle explicit ./script or just script name if in current dir
                    // Try to resolve as path first
                    let execRes = resolvePath(cmd);

                    // If it resolves to a file, execute it
                    if (execRes.node && execRes.node.type === 'file') {
                        let file = execRes.node;
                        let fileName = execRes.path[execRes.path.length - 1];

                        if (file.action === 'navigate') {
                            print(`Executing ${fileName}...`, 'success');
                            setTimeout(() => window.location.href = file.url, 800);
                        } else if (file.action === 'download') {
                            print(`Downloading ${fileName}...`, 'success');
                            const link = document.createElement('a');
                            link.href = file.url;
                            link.download = '';
                            link.click();
                        } else {
                            // Treat as cat/execute text script
                            if (file.content) print(file.content);
                            else print("Execution finished.", 'success');
                        }
                        return;
                    }

                    // Fallback: check if user tried `python script.py` or similar
                    if (cmd === 'python' || cmd === 'bash' || cmd === 'open') {
                        if (args.length > 0) {
                            // Recursive call to execute the argument
                            execute(args[0]);
                        } else {
                            print(`usage: ${cmd} [file]`, 'info');
                        }
                    } else {
                        print(`command not found: ${cmd}`, 'error');
                    }
            }
        }

        function updatePrompt() {
            const pathStr = currentPath.length === 2 ? '~' : '~/' + currentPath.slice(2).join('/');
            promptSpan.innerText = `visitor@hugo-portfolio:${pathStr}$`;
        }

        // --- Input Handling ---
        inputField.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                const val = inputField.value;
                const parts = val.split(' ');
                const lastWord = parts[parts.length - 1];

                // Autocomplete Commands logic
                // If simple word and no path indicators
                const isPath = lastWord.includes('/') || lastWord === '.' || lastWord === '..';

                if (parts.length === 1 && !isPath) {
                    const commands = ['help', 'ls', 'cd', 'cat', 'clear', 'whoami', 'exit', 'reboot', 'matrix', 'open', 'python', 'bash'];
                    const matches = commands.filter(c => c.startsWith(lastWord));
                    if (matches.length === 1) {
                        inputField.value = matches[0] + ' ';
                    } else if (matches.length > 1) {
                        printHTML(`<div class="border-b border-dashed border-slate-700 mb-2"></div>
                        <div class="text-slate-500 text-xs mb-2 grid grid-cols-4 gap-2">
                            ${matches.map(m => `<span>${m}</span>`).join('')}
                        </div>`);
                    } else if (val.trim() === '') {
                        printHTML(`<div class="border-b border-dashed border-slate-700 mb-2"></div>
                        <div class="text-slate-500 text-xs mb-2 grid grid-cols-4 gap-2">
                            ${commands.map(m => `<span>${m}</span>`).join('')}
                        </div>`);
                    }
                } else {
                    // Path Autocomplete
                    // We need to resolve the directory part of the lastWord to find candidates
                    // lastWord could be: "projects/" -> dir="projects", prefix=""
                    // "projects/ki" -> dir="projects", prefix="ki"
                    // "./" -> dir=".", prefix=""
                    // "ki" -> dir=".", prefix="ki"

                    let dirPathStr = ".";
                    let searchPrefix = lastWord;

                    if (lastWord.lastIndexOf('/') !== -1) {
                        const lastSlash = lastWord.lastIndexOf('/');
                        dirPathStr = lastWord.substring(0, lastSlash + 1); // include slash for resolving
                        searchPrefix = lastWord.substring(lastSlash + 1);
                    } else {
                        // searchPrefix is the whole word, dir is current
                    }

                    // Resolve the directory
                    const res = resolvePath(dirPathStr);

                    if (res.node && res.node.type === 'dir') {
                        const candidates = Object.keys(res.node.children);
                        const matches = candidates.filter(c => c.startsWith(searchPrefix));

                        // Prefix for replacement
                        // If user typed "projects/ki", replacement should be "projects/kinova..."
                        // dirPathStr is "projects/"

                        // Special case: if dirPathStr is just ".", we don't want to prefix "." unless user typed it?
                        // If user typed "ki", dirPathStr=".", we replace "ki" with "kinova..."
                        // If user typed "./ki", dirPathStr="./", we replace "./ki" with "./kinova..."
                        // So we just prepend dirPathStr IF it was part of input?

                        let replacementPrefix = "";
                        if (lastWord.lastIndexOf('/') !== -1) {
                            replacementPrefix = dirPathStr;
                        }

                        if (matches.length === 1) {
                            parts[parts.length - 1] = replacementPrefix + matches[0];
                            if (res.node.children[matches[0]].type === 'dir') {
                                parts[parts.length - 1] += '/';
                            }
                            inputField.value = parts.join(' ');
                        } else if (matches.length > 1) {
                            printHTML(`<div class="border-b border-dashed border-slate-700 mb-2"></div>
                            <div class="text-slate-500 text-xs mb-2 grid grid-cols-4 gap-2">
                                ${matches.map(m => `<span>${replacementPrefix + m}</span>`).join('')}
                            </div>`);
                        } else if (searchPrefix.trim() === '') {
                            printHTML(`<div class="border-b border-dashed border-slate-700 mb-2"></div>
                            <div class="text-slate-500 text-xs mb-2 grid grid-cols-4 gap-2">
                                ${candidates.map(m => `<span>${replacementPrefix + m}</span>`).join('')}
                            </div>`);
                        }
                    }
                }

            } else if (e.key === 'Enter') {
                const val = inputField.value;
                if (val.trim()) execute(val);
                inputField.value = '';
            } else if (e.key === 'ArrowUp') {
                if (historyIndex > 0) {
                    historyIndex--;
                    inputField.value = commandHistory[historyIndex];
                }
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    inputField.value = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    inputField.value = '';
                }
                e.preventDefault();
            }
        });

        // --- Matrix Effect ---
        function startMatrix() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const fontSize = 16;
            const columns = canvas.width / fontSize;
            const drops = Array(Math.floor(columns)).fill(1);

            function draw() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#0F0';
                ctx.font = fontSize + 'px monospace';

                for (let i = 0; i < drops.length; i++) {
                    const text = letters.charAt(Math.floor(Math.random() * letters.length));
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
                if (canvas.style.display === 'block') requestAnimationFrame(draw);
            }
            draw();
        }
    </script>
</body>

</html>